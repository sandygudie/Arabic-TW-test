حاويات (rr-renv) =
# الحاويات

(rr-renv-buers-why)=
## لماذا الحاويات؟

وحتى بالنسبة للمشاريع المعقدة، يمكن أن يكون حجم مجموعة الاعتماد على البرمجيات ضخما. خذ خط أنابيب بسيط لبناء تقرير pdf لتحليل نصي في R باستخدام `Rmarkdown`، على سبيل المثال. لجعل هذا قابل للتأثر، لا يقتصر الأمر على ما يلي: `1` ضرورة تركيب حزم إعادة التدوير ذات الصلة، و`2` ضرورة أن تكون صيغة إعادة التدوير هي نفسها، ولكن أيضا '3` إصدارات `Pandoc` و `LaTeX` يجب أن تكون نفس الإصدارات أثناء التشغيل.

وبدلاً من محاولة حل هذه التبعيات عن طريق مدير مجموعة (مثل كوندا) - وهو ما يعتمد أيضاً على توافر جميع البرمجيات المطلوبة في مدير حزمة واحد - قد يكون من الأسهل إنشاء لقطة لبيئة الحوسبة بأكملها بما في ذلك جميع التبعيات. بعد ذلك تكون هذه البيئات الحاسوبية قائمة بذاتها، ومن ثم اسم "الحاويات".

(rr-renv-buers-what)=
## ما هي الحاويات؟

تسمح الحاويات للباحث بتجميع مشروع مع جميع الأجزاء التي يحتاج إليها - مثل المكتبات، الإعتمادات، وإعدادات النظام - وشحنها كلها كحزمة واحدة. ويمكن لأي شخص بعد ذلك أن يفتح حاوية ويعمل داخلها، مشاهدة المشروع والتفاعل معه كما لو أن الآلة التي يصلون إليها متطابقة مع الآلة المحددة في الحاوية - بغض النظر عن البيئة الحسابية الخاصة بهم _بالفعل_. تم تصميمها لجعلها أسهل نقل المشاريع بين بيئات مختلفة جدا.

بطريقة ما ، الحاويات تتصرف كآلة افتراضية. وبالنسبة للعالم الخارجي، تبدو وكأنها نظامها الكامل. ومع ذلك، وخلافا لآلة افتراضية، بدلا من إنشاء نظام تشغيل افتراضي كامل بالإضافة إلى جميع البرمجيات والأدوات المعبأة عادة بنظام واحد، ولا تتضمن الحاويات إلا المكونات الفردية التي تحتاجها لتشغيل المشروع الذي تحتويه. وهذا يعطي دفعة كبيرة للأداء ويقلل من حجم التطبيق.

وتعتبر الحاويات وسيلة مفيدة بشكل خاص لاستنساخ البحوث التي تعتمد على برمجيات لتكوينها بطريقة معينة. أو التي تستخدم المكتبات التي تختلف بين النظم المختلفة (أو لا توجد فيها). وباختصار، الحاويات هي طريقة أكثر قوة لتقاسم البحوث القابلة للاستنساخ من نظم إدارة الطرود أو بيندر لأنها تستنسخ كامل النظام المستخدم في البحوث، ليس فقط الحزم التي استخدمها صراحة. وجوهها السلبي الرئيسي هو ذلك بسبب عمقها الأكبر، وهي أصعب من الناحية المفاهيمية من العديد من الأساليب الأخرى لتكرار البيئات الحسابية.

يقدم بن كوري نظرة عامة سهلة المنال بشكل معقول للمفاهيم الأساسية في ['ما هي الحاوية؟'](https://www.youtube.com/watch?v=EnJ7qX9fkcU).

(rr-renv-containers-images)=
## ما هي الصور؟

الصور هي الملفات المستخدمة لإنشاء الحاويات. البشر لا يصنعون الصور، إنهم يكتبون وصفات لتوليد الصور. وعندئذ تكون نسخ الحاويات مطابقة من الصور.

فكر في ذلك مثل:

- ملف وصفة مكتوب بشري يحتوي على جميع الخطوات لتوليد نسخة عمل من المشروع وبيئته الحاسوبية. ولكن لا توجد مواد فعلية. فكر في هذا كمخطط.
- بناء صورة يأخذ تلك الوصفة ويستخدمها، يجمع كل الحزم، مكتبات البرمجيات، و التشكيلات اللازمة لإنشاء المشروع الكامل والبيئة و تجميعهما في مجموعة مختصرة. فكر في صور مثل قطعة من الأثاث المسطح مصنوعة باستخدام المخطط.
- وتأخذ الحاويات هذه الصورة وتجمع نسخة كاملة العمل من المشروع والبيئة اللازمة لتشغيله. فكر في هذا على أنه تجميع لأثاث الحزمة المسطحة.

لذا إذا أراد أحد الباحثين السماح للآخرين باستنساخ عملهم، سيحتاجون إلى كتابة ملف وصفة ، ويستخدمونه لبناء صورة لمشروعهم. يمكنهم بعد ذلك مشاركة ملف الصورة هذا مع أي شخص يريد تكرار عملهم. ويمكن لذلك الشخص أن يستخدم الصورة لتوليد حاوية تحتوي على نسخة عمل من المشروع.

(rr-renv-buers-docker)=
## ما هو دوكر؟

وهناك العديد من الأدوات المتاحة لإنشاء الحاويات والعمل معها. وسوف نركز على شركة Docker، التي تستخدم على نطاق واسع، ولكننا ندرك أن هناك أمورا أخرى مثل التفرد. يفضل التفرد في بعض الأحيان لاستخدامه في نظم الحوسبة عالية الأداء لأنه لا يحتاج إلى أذونات `sudo` ليتم تشغيلها، في حين يفعل Docker.

في Docker، تُعرف ملفات الوصفات المستخدمة لإنشاء الصور باسم Dockerfiles، ويجب أن تسمى `Dockerfile`.

[Docker Hub](https://hub.docker.com/) يستضيف العديد من الصور المصنوعة مسبقاً، مثل [صور](https://hub.docker.com/_/ubuntu) لماكينات أوبونتو، التي يمكن تنزيلها والبناء عليها. هذا يجعل عملية كتابة Dockerfiles سهلة نسبياً لأن المستخدمين نادراً ما يحتاجون إلى البدء من الصفر، يمكنهم فقط تخصيص الصور الموجودة. ومع ذلك، فإن هذا يجعل المستخدم عرضة لمشاكل أمنية مشابهة على النحو الموصوف في {ref}`rrr-renv-yaml-Security` من الفصل الفرعي {ref}`rrr-renv-yaml`:

- من الممكن تضمين التعليمات البرمجية الضارة في صور Docker
- ومن الممكن للأشخاص الذين ينتجون الصور أن يدرجوا فيها دون علم برمجيات ذات مواطن ضعف أمنية.

[هذه المقالة](https://opensource.com/business/14/7/docker-security-selinux) تذهب أعمق إلى نقاط الضعف الأمنية المحتملة للحاويات، وهنا [تفصيل تفصيلي](https://opensource.com/business/14/9/security-for-docker) لميزات الأمان الحالية داخل Docker, و كيفية عملهم. أفضل نصيحة لاستخدام الصور التي بناها الآخرون هو، كالمعتاد، قم بتنزيل وتشغيل شيء ما على جهازك فقط إذا كان من مصدر موثوق به. Docker Hub لديه شارات "صورة رسمية" للصور الشائعة الاستخدام والمتحقق منها كما هو مبين هنا:

```{figure} ../../figures/docker-official-image.png
---
الاسم: docker-official-image
البديل : لقطة شاشة من شارات الصور الرسمية
---
```

(rr-renv-containers-installdocker)=
## تثبيت Docker

أجهزة تثبيت Docker على مجموعة متنوعة من الأنظمة المختلفة متوفرة [هنا](https://docs.docker.com/install/). تعليمات التثبيت التفصيلية متوفرة أيضا لمجموعة متنوعة من أنظمة التشغيل مثل [Ubuntu](https://docs.docker.com/install/linux/docker-ce/ubuntu/)، [Debian](https://docs.docker.com/install/linux/docker-ce/debian/)، [Macs](https://docs.docker.com/docker-for-mac/install/)، و [Windows](https://docs.docker.com/docker-for-windows/install/).

(rr-renv-containers-commands)=
## أوامر المفتاح

فيما يلي بعض الأوامر الرئيسية لإنشاء الحاويات والعمل معها:

- لبناء صورة من ملف Dockerfile، انتقل إلى الدليل حيث ملف Dockerer وتشغيل:
  ```
  سوكدو دفتر إنشاء - وسم الصورة_الاسم .
  ```
- لتسجيل الصور على النظام الخاص بك، استخدم:
  ```
  صور Ssudo Socker
  ```
- لإزالة صورة، قم بتشغيل:
  ```
  صورة_اسم Ssudo docker rmi
  ```
- لفتح حاوية من صورة، قم بتشغيل:
  ```
  sudo docker تشغيل -i -t image_name
  ```
  `-i -t` يفتح تلقائياً محطة طرفية تفاعلية داخل الحاوية حتى تتمكن من عرض ملفات المشروع والتفاعل معها.
- للخروج من محطة طرفية تفاعلية، استخدم:
  ```
  الخروج
  ```
- للحصول على قائمة بالحاويات النشطة مع المعرفات، قم بتشغيل:
  ```
  حاويات مرفأ سوكر
  ```
- وهناك أيضا ثلاثة أوامر رئيسية تستخدم لتغيير حالة الحاويات:
  - إيقاف العملية التي تشغل الحاوية مؤقتاً مؤقتاً.
    ```
    معرف حاوية السوكر مؤقتاً
    ```
    يمكن عدم إيقاف الحاويات مؤقتاً عن طريق استبدال `إيقاف مؤقت` بـ `عدم إيقاف مؤقت`.
  - إيقاف حاوية ما يؤدي إلى إنهاء العملية التي تشغلها. يجب إيقاف الحاوية قبل أن يمكن حذفها.
    ```
    سوكدو يوقف الحاوية_ID
    ```
    يمكن إعادة تشغيل الحاوية الموقوفة عن طريق استبدال `توقف` بـ `إعادة تشغيل`.
  - إذا `إيقاف` لا يمكن قتل حاويات العمل باستخدام
    ```
    سوكدو مقتل الحاوية_ID
    ```
- لإزالة الحاوية، قم بتشغيل:
  ```
  sudo docker rm container_ID
  ```
(rr-renv-containers-dockerfiles)=
## كتابة ملفات Dockerfiles

دعونا نمر عبر تشريح دكيرفيلٍ بسيط جداً:

```
# الخطوة 1: إعداد البيئة الحسابية

# تعيين الصورة الأساسية
من ubuntu:18. 4

# الحزم التثبيت المطلوبة لتشغيل المشروع
تحديث RUN apt-get && \
    apt-get install -y --no-install-recommends python3. python3-pip && \
    rm -rf /var/lib/apt/lists/*
RUN python3 -m pip install numpy

#-------------------------

# الخطوة 2: إدراج ملفات المشروع في الصورة

# نسخ الملفات من دليل `project_files' على بناء صورة الآلة
# في مجلد `project` في الحاوية. هذا المجلد وأي أدلة مفقودة
# في مساره يتم إنشاؤها تلقائيا.
مشروع_ملفات/مشروع/COPY
```

هذا يبدو معقدا، ولكن معظم الأسطر في هذا المثال هي تعليقات (يسبقها `#`'s). وهناك ستة أسطر فقط من الشفرة الفعلية. الأول من هذه البيانات هو عبارة `من` تحدد صورة أساسية. جميع ملفات Dockerfiles تتطلب منبثقة، حتى لو كانت فقط `من سكراتش`. جميع الأوامر التالية في Dockerfile مبنية على الصورة الأساسية لإنشاء نسخة فعالة من مشروع الباحث. تحديد إصدار للصورة (`18.04` في هذه الحالة) اختياري. بيد أن هذه الممارسة هي أفضل الممارسات لأنها تكفل بقاء ملف Dockerfile الخاص بنا ساري المفعول بعد صدور إصدارات جديدة من Ubuntu، التي قد لا تشمل الحزم (أو إصدارات محددة منها) التي نحتاجها في وقت لاحق (على سبيل المثال `python3.`).

من الجدير قضاء الوقت لاختيار صورة أساسية ملائمة، كما أن القيام بذلك يمكن أن يقلل من حجم العمل الذي ينطوي عليه كتابة ملف Dockerfile بشكل كبير. على سبيل المثال، يمكن العثور على مجموعة من الصور مع لغة البرمجة R المضمنة فيها [هنا](https://github.com/rocker-org/rocker-versioned). إذا استفاد مشروع ما من "ص"، من المناسب استخدام واحدة من هذه كصورة أساسية بدلاً من قضاء الوقت في كتابة أوامر Dockerfile لتثبيت R.

أكبر كتلة من الخطوط تأتي بعد ذلك. إنها سلسلة من `بيانات RUN` التي تشغل أوامر القذيفة عند بناء الصورة. في هذه الكتلة، يتم استخدامها لتثبيت البرمجيات اللازمة لتشغيل المشروع. كتلة `RUN` الأولى هي سلسلة أوامر من هذا النموذج:

```
RUN command_to_do_thing_1 \
   && command_to_do_thing_2 \
   && command_to_do_thing_3 \
   && command_to_do_thing_4
```

من الممارسات الجيدة تجميع الأوامر ذات الصلة في كتلة واحدة `RUN` لتقليل الحجم النهائي لصورك ب [لتجنب إنشاء طبقات غير ضرورية](https://docs.docker.com/develop/develop-images/#minimize-the-number-of-layers). نحن أيضا نتابع أفضل الممارسات باستخدام `--no-install-recommend` إلى [لتجنب تثبيت حزم غير ضرورية](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#dont-install-unnecessary-packages) و [لتنظيف ذاكرة التخزين المؤقت ``](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#run)، وكلاهما يقلل من حجم صور ديبا أو أوبونتو.

بعد أن قمنا بتثبيت Python، نستخدم بيان RUN آخر لتثبيت مكتبة مطلوبة بواسطة التعليمات البرمجية.

أخيرا يتم استخدام أمر `COPY` لنسخ ملفات المشروع من الماكينة التي تبني الصورة إلى الصورة نفسها. بناء الجملة لهذا الأمر هو `COPY file_to_coplocation_in_container_to_copy_to`. في هذا المثال ، يتم تضمين جميع الملفات في دليل `project_files` في ملف المشروع `` في الحاوية. لاحظ أنه يمكنك فقط نسخ الملفات من الدليل حيث يوجد ملف Docker، أو الدلائل الفرعية داخلها (في المثال ، هذا هو `project_files` subdirectory).

الأمر `المضاف` لديه نفس القدرات مثل `COPY`، ولكن يمكن استخدامه أيضا لإضافة ملفات ليست على مبنى الآلة للصورة. على سبيل المثال، يمكن استخدامه لتضمين الملفات المستضيفة عبر الإنترنت من خلال متابعة `إضافة` مع عنوان URL للملف. من الممارسات الجيدة استخدام `COPY`، باستثناء حيث `إضافة` مطلوبة تحديداً. كما أن مصطلح `COPY` هو أكثر وضوحا بشأن ما يجري عمله.

إليك ما يحدث إذا تم فتح حاوية من صورة تسمى `book_example`، مبنية من المثال أعلاه:

```{figure} ../../figures/container-example.png
---
الاسم: مثال الحاوية
البديل: لقطة شاشة لما يحدث عند فتح حاوية من صورة
---
```

كما ترون، تم إنشاء الدليل `المشروع` وداخل ملفات المشروع `تحليل. y` و `data.csv` تم نسخها فيها. لأن Dockerfile يحتوي بالفعل على البرنامج المطلوب للمشروع، في الصورة، يعمل البرنامج النصي `analysis.py` دون تثبيت المزيد من البرامج.

(rr-renv-containers-dockerfiles-workdir)=
### `دوري`

يمكن استخدام هذا الأمر في Dockerfiles لتغيير دليل العمل الحالي. الأوامر التي تتبع هذا في ملف Dockerfile سيتم تطبيقها داخل دليل العمل الجديد ما لم/حتى يقوم `WORKDIR` بتغيير دليل العمل. وعندما تفتح حاوية بمحطة طرفية تفاعلية، تفتح المحطة الطرفية في دليل العمل النهائي. هنا مثال بسيط لملف Dockerfile الذي يستخدم `WORKDIR`والحاوية التي يولدها.

```
# الإعداد الأساسي
من أوبونتو
تحديث RUN apt-get

# اصنع مجلد يسمى A
RUN mkdir A

# اجعل دليل العمل A
WORKDIR A

# اصنع دليلين، واحد يسمى B_1 وواحد يسمى B_2
RUN mkdir B_1
RUN mkdir B_2
```

```{figure} ../../figures/workdir-example.png
---
الاسم: workdir-example
البديل : لقطة الشاشة للحاوية التي تم إنشاؤها باستخدام الأمر WORKDIR
---
```

تم إنشاء الدليلين `B_1` و `B_2` داخل الدليل `A`.

`WORKDIR` يجب أن تستخدم عندما يكون تغيير الدلائل ضرورياً أثناء بناء صورة. قد يكون من المغري استخدام `RUN cd directory_name` بدلاً من ذلك، لأن هذه الجملة ستكون أكثر إلماماً بتلك التي تعمل عادة عبر سطر الأوامر، ولكن هذا يمكن أن يؤدي إلى أخطاء. بعد كل بيان `RUN` في ملف Dockerfile، يتم حفظ الصورة، ويتم تطبيق أي الأوامر التالية على الصورة من جديد. على سبيل المثال، هنا ما يحدث في المثال أعلاه إذا تم تبديل سطر `WORKDIR A` مقابل `RUN cd A`.

```{figure} ../../figures/cd-example.png
---
الاسم: مثال cd-example
البديل : لقطة شاشة لما يحدث عندما يتم تبديل أمر WORKDIR مع RUN cd
---
```

جميع الدلائل كانت في أعلى مستوى في هذه الحالة، بدلاً من أن يكون `B_1` و `B_2` داخل `A`. هذا لأن الصورة تمت إعادة تشغيلها بعد أمر `RUN cd A` وفتحها في أعلى مستوى (الجذر) بشكل افتراضي، بحيث يكون هذا هو المكان الذي بدأ فيه نفاذ الأوامر `mkdir B_1` و `mkdir B_2`.

(rr-renv-containers-dockerfiles-commands)=
### أوامر أخرى

وتشمل الأوامر الأخرى التي تستخدم في بعض الأحيان في Dockerfiles ما يلي:

- `CMD`: يستخدم هذا لتشغيل الأوامر بمجرد فتح الحاوية. هذا مختلف عن أوامر RUN التي هي أوامر تعمل كجزء من _إعداد_ حاوية. على سبيل المثال، للحصول على رسالة ترحيب عند فتح حاوية من الصورة، يمكن استخدام `CMD` على النحو التالي:
  ```
  CMD ["صديق"،"مرحباً! لقد فتحت هذه الحاوية!"]
  ```
  من الممارسات الجيدة استخدام CMD لأي أوامر تحتاج إلى تشغيلها قبل أن يبدأ شخص العمل في الحاوية بدلا من إجبار المستخدمين على تشغيلها بأنفسهم (والثقة بأنهم سيعلمون حتى أنهم بحاجة إليهم).
- `الأصوات`: سيتم مناقشة هذه {ref}`لاحقاً <rr-renv-containers-volumes>`.
- `MAINTAINER`: يحتوي هذا على معلومات عن الشخص الذي كتب ملف Dockerfile. ويدرج عادة في الجزء العلوي من ملف Dockerfile.
- `EXPOSE`: هذا يشمل المنافذ التي يجب أن تكون معرضة. هو أكثر صلة بالناس الذين يستخدمون Docker لمشاركة تطبيقات الويب.
- `USER`: تغيير المستخدم الذي يتم تشغيل أمر ك(مفيد لإسقاط الامتيازات).

(rr-renv-containers-dockerignore)=
## صور البناء و `.dockerignore` ملفات

كما ذكر في {ref}`أوامر المفاتيح <rr-renv-containers-commands>` القسم ، لبناء صورة فتح محطة طرفية في نفس الدليل كـ ملف Dockerfile الذي سيتم استخدامه وتشغيله:

```
قم بتركيب منصة الدفتر - وسم الاسم_إلى_give_image .
```

عندما يتم بناء صورة كل شيء في دليل Dockerfile's و أدناه (هذا يسمى "السياق") يتم إرساله إلى Docker daemon لبناء الصورة. يستخدم دايمون Dockerfile وسياقه لبناء الصورة. إذا كان السياق يحتوي على العديد من الملفات الكبيرة، التي ليست ضرورية لبناء الصورة، (مثلا ملفات البيانات القديمة) ثم هي مضيعة للوقت ترسلها إلى المكان. والقيام بذلك يمكن أن يجعل عملية بناء صورة بطيئة. يمكن استبعاد الملفات من السياق عن طريق إدراجها في ملف نصي يسمى `.dockerignore`. ومن الممارسات الجيدة القيام بذلك.

لا تحتاج الملفات إلى أن تكون مدرجة بشكل فردي في ملف `.dockerignore`. فيما يلي مثال على محتويات ملف `.dockerignore`:

```
*.jpg
**/*.png
data_files/*
file_to_exclude.txt
```

وهذا يستبعد من السياق:

- كل ملفات `.jpg` في نفس الدليل كملف Dockerfile
- كل ملفات `.png` في نفس المجلد مثل ملف Dockerfile _أو أي أدلة فرعية داخله_
- جميع الملفات داخل دليل `data_files`
- الملف المسمى `file_to_exclude.txt`

(rr-renv-containers-Sharing)=
## مشاركة الصور

يمكن مشاركة صور Docker بسهولة أكبر من خلال [Docker Hub](https://hub.docker.com/)، الذي يتطلب حساب. قل باحثين، أليس وبوب، يتعاونون في مشروع وترغب أليس في مشاركة صورة لبعض عملها مع بوب.

للقيام بذلك، يجب على أليس أن:

- اكتب ملف Dockerfile لإنتاج صورة لعملها.
- بناء الصورة. هي (تكون مبتكرة) تدعوها image_name
- اذهب إلى DockerHub و قم بالتسجيل للحصول على حساب. قل أليس (مرة أخرى، كونك مبتكر) يختار اسم المستخدم `username_Alice`
- تسجيل الدخول إلى DockerHub عبر المحطة الطرفية على جهازها باستخدام ما يلي:
  ```
  تسجيل الدخول لـ sudo docker
  ```
- وضع علامة على صورة مشروعها على جهازها عبر سطر الأوامر عن طريق تقديم اسم الصورة واستخدام نمط `اسم المستخدم/image_name:version`. إذاً تقوم أليس بتشغيل الأمر:
  ```
  سرد علامة Docker imagage_name username_Alice/image_name:version_1
  ```
- اضغط الصورة إلى حسابها في مركز دوكر باستخدام :
  ```
  قم بالضغط على اسم المستخدم - Alice/image_name:version_1
  ```
- صورة أليس الآن على الإنترنت ويمكن تنزيلها. من جديد إلى بوب...

بوب (بافتراض أن Docker مثبت) يمكنه فتح حاوية من صورة أليس بمجرد تشغيلها

```
قم بتشغيل-i -t username_Alice/image_name:version_1
```

مبدئيًا، سيقوم Docker بالبحث عن هذه الصورة على آلة Bob. عندما لا يجد ذلك، فإنه _تلقائيًا_ بحث DockerHub، قم بتنزيل صورة أليس وفتح الحاوية مع عمل أليس وبيئتها على آلة بوب.

(rr-renv-containers-copying)=
## نسخ الملفات إلى الحاويات ومن الحاويات

الحاويات تعمل مثل الماكينات الافتراضية؛ ونتيجة لذلك، فإن نسخ الملفات إلى الداخل والخروج منها ليس تافهاً مثل نسخ الملفات إلى مواقع مختلفة داخل نفس الحاسوب.

يمكن نسخ ملف من الآلة التي تقوم بتشغيل حاوية إلى الحاوية باستخدام ما يلي:

```
سرد ملف cp الخاص بالدفتر_اسم الحاوية_ID:path_to_where_to_put_file/file_name
```

قم بالتذكير بأنه يمكن الحصول على معرفات الحاويات باستخدام `سودو دفتر الحاويات`.

يمكن نسخ ملف من داخل الحاوية إلى الآلة التي تشغل الحاوية عن طريق تشغيل الأمر التالي على الآلة التي تشغل الحاوية:

```
سرد حاوية قفص الجدار_ID:path_to_file/file_name path_to_to_to_put_file/file_name
```

إذا تم استبدال الجزء الثاني ( `path_to_where_to_put_file/file_name`بـ `.`، ثم سيتم نسخ الملف إلى أي دليل تقوم المحطة الطرفية بتشغيل الأمر.

(r-renv-buers-volumes)=
## الصوت

وفي كل مرة تفتح فيها حاوية من صورة، تكون تلك الحاوية جديدة تماما. قل أن الحاوية تفتح، والعمل في داخلها. إذا كانت تلك الحاوية مغلقة، والصورة التي أتت منها تستخدم مرة أخرى لبدء حاوية أخرى، ولن يكون أي عمل من هذا القبيل في العمل الجديد. وسيكون لها ببساطة حالة البداية الموصوفة في الصورة.

ويمكن أن تكون هذه مشكلة إذا أراد أحد الباحثين العمل في حاوية مع مرور الوقت. لحسن الحظ، هناك طريقة حول هذا باستخدام المجلدات. وتخزن المجلدات العمل المنجز داخل حاوية حتى بعد إغلاقها، ويمكن استخدامها لتحميل ذلك العمل في حاويات مقبلة.

لإنشاء / استخدام مجلد، تشغيل:

```
sudo docker تشغيل -i -t --mount source=volume_name,target=/target_directory image_name
```

يجب أن تعطي المجلد الخاص بك إسم وصفي أكثر من `volume_name`. مجلد `الهدف` مطلوب؛ العمل داخل هذا الدليل فقط سيتم حفظه في المجلد. وبمجرد قيام الباحث بإغلاق الحاوية كأمر عادي. وعندما يعودون إلى المشروع ويرغبون في مواصلة عملهم، فإنهم لا يحتاجون إلا إلى استخدام نفس الأمر الوارد أعلاه، وستقوم بتحميل العمل الوارد في `volume_name` في الحاوية الجديدة. وسيوفر أي عمل جديد هناك أيضا.

فيما يلي قائمة بالأوامر ذات الصلة بالمجلد:

- لتسجيل المجلدات: `سودو دفتر الصوت`
- لحذف مجلد: `sudo docker volume rm volume_name`
- لحذف جميع المجلدات غير المرتبطة: `تمايز مستوى الصوت sudo docker`

إذا كان عند حذف الحاوية، `-v` تم تضمينه بعد `rm` في `sudo docker rm container_ID`، سيتم أيضا حذف أي مجلدات مرتبطة بالحاوية.

(rr-renv-containers-singarity)=
## التفرد


> **المتطلبات الأساسية**: في الوقت الحاضر، يعمل التفرد فقط على أنظمة لينكس (على سبيل المثال أوبونتو). إذا كنت تستخدم macOS، [سطح المكتب الفردي لـ macOS](https://www.sylabs.io/singularity-desktop-macos/) في مرحلة الإصدار "Beta".

ومن العيوب الهامة لاستخدام Docker في البحوث القابلة للتكرار، أنه لا يقصد به أن يكون تطبيقا للفضاء بين المستخدمين، بل أن يكون أداة لمديري الخوادم. ومن هذا المنطلق، يتطلب الوصول الجذري إلى العمل. غير أنه لا يوجد سبب يدعو إلى أن يتطلب إجراء تحليل إمكانية وصول المستعملين إلى جذورها. وهذا مهم بشكل خاص عندما تجري الحسابات على مورد مشترك مثل نظم HPC حيث لن يكون للمستخدمين أي إمكانية للوصول إلى الجذر.

تم تقديم برنامج حاوية [وحدة](https://www.sylabs.io/) لمعالجة هذه المشكلة. تم إنشاء وحدة مع أنظمة HPC والبحوث القابلة لإعادة التدوين في الاعتبار (انظر \[this\](https://www.youtube.com/watch?v=DA87Ba2dpNM فيديو). لا يتطلب الوصول إلى الجذر لتشغيله (فقط لبناء حاوية _صور_! ومن ثم يمكن مستخدمي الحواسيب HPC من بناء صور للحاويات محليا قبل إجراء تحليلات لمجموعة عالية الأداء، على سبيل المثال. وكمنفعة إضافية، وهذا يجعل من الممكن استخدام أي برنامج حاسوبي تقريبا على نظام HPC دون الحاجة إلى إثراء الموظفين الإداريين بتثبيته.

علاوة على ذلك، بما أن Docker هو __ نهج النقل بالحاويات الأكثر شهرة، فإن التفرد يهدف إلى الحفاظ على التوافق مع حاويات الرصيف. هذا يعني أنه يمكن استخدام الوحدة لتشغيل حاويات الأرصفة العادية (دون الحاجة إلى الوصول إلى الجذر!).

يمكن استخدام التفرد لتشغيل صور Docker أو توسيعها عن طريق بناء صور جديدة مبنية على حاويات الأرصفة كطبقة قاعدة. على سبيل المثال، يمكننا استخدام التفرد لإنشاء حاوية فانيليا أوبونتو مع قذيفة باستخدام صورة رصيف أوبونتو:

```
قذيفة مفردة docker://ubuntu
```

> (اكتب `الخروج` لمغادرة القذيفة التفاعلية مرة أخرى).

تماما كما يتم بناء صور المرفأ باستخدام ملفات `Dockerfile` ، يتم بناء حاويات التفرد من ملفات تعريف الوحدة. العملية و الجملة مشابهة لملف المرفأ، ولكن هناك اختلافات دقيقة. كحد أدنى من الأمثلة على العمل، يمكننا بناء حاوية `Lolcow` استنادًا إلى صورة حاوية حاوية أوبونتو الرسمية. ضع ما يلي في ملف `lolcow.def` (استناداً إلى [مستندات التفرد](https://www.sylabs.io/guides/3.2/user-guide/build_a_container.html):
```
Bootstrap: docker
من: ubuntu

%post
    apt-get -y تحديث
    apt-get - y install ثروة البقر

%en<unk> ment
    تصدير LC_ALL=C
    تصدير PATH=/usr/games:$PATH

%runscript
    fortune <unk> cowsay <unk> lolcat
```

هذه 'الوصفة' تستخدم صورة دفتر كأساس (`ubuntu`)، تثبيت بعض `حزم apt` ، وتعديل بعض متغيرات البيئة ، ويحدد البرنامج النصي `` (الذي يتم تنفيذه باستخدام `تشغيل الوحدة` الأمر). يمكن العثور على تفاصيل تنسيق ملف تعريف التفرد في [الوثائق الرسمية](https://www.sylabs.io/docs/).

بعد ذلك يمكن بناء صورة حاوية (تتطلب جذر!) من خلال:

```
قم ببناء الوحدة lolcow.simg lolcow.def
```

سيؤدي هذا إلى سحب صورة أوبونتو من دوكيرهوب، قم بتشغيل خطوات الوصفة في ملف التعريف وانتاج ملف صورة مخرج واحد (`Lolcow. img`). أخيرا تم تنفيذ `runscript` كـ

```
وحدة تشغيل lolcow.simg
```

من الناحية المثالية، يجب أن ترى بقرة لطيفة من طراز ASCII وبعض كلمات الحكمة:

```
___________________________________
/ سيتم دعوتك لمساعدة \
\ صديق في مشكلة.                /
-----------------------------------
       \   ^__^
        \  (oo)\_______
           (__)\       )\/\
               ||----w |
               ||     ||
```

وبما أن الحاويات تتمشى مع HPC، فإن الحاويات الفريدة مدعومة أيضا بطائفة واسعة من أدوات إدارة سير العمل. على سبيل المثال، يدعم كل من [snakemake](https://snakemake.readthedocs.io/en/stable/) و [nextflow](https://www.nextflow.io/docs/latest/singularity.html) حاويات أحادية لوظيفة محددة. وهذا يجعل الحاويات الفريدة مناسبة بشكل فريد لتوازي تدفق العمل في نظم HPC باستخدام مدير عبء العمل في [الفقير](https://slurm.schedmd.com/documentation.html) المستخدم على نطاق واسع. فاستخدام التفرد والحاويات والتدفق اللاحق هو طريقة لتوسيع نطاق إمكانية التكرار إلى نطاق هائل. وعلاوة على ذلك، وكفائدة إضافية، لم يعد جلب تدفقات العمل من آلة حاسوبية مكتبية إلى نظام HPC يتطلب كتابة نصوص مخصصة لتقديم الوظائف.

(rr-renv-containers-singarity-storage)=
### التخزين الطويل الأجل لصور الحاويات

ومن المهم الإشارة إلى أن مجرد ملف وصفة الحاويات لا يمكن تكراره في حد ذاته لأن عملية البناء تعتمد على مصادر مختلفة (متاحة على الإنترنت). ومن ثم فإن نفس ملف الوصفة قد يؤدي إلى صور مختلفة إذا تم تحديث المصادر الأساسية.

لتحقيق إمكانية التكرار الحقيقية، من المهم تخزين الحاوية الفعلية _صور_. بالنسبة لصور التفرد، هذا أمر سهل بشكل خاص لأن الصورة هي ببساطة ملف كبير. ويمكن أن تختلف هذه الأشكال من حيث الحجم، من بضع عشرات من الحاويات الدقيقة إلى عدة غيغابايت، وبالتالي فهي غير مناسبة لتخزينها في مستودع git نفسه مجاناً، والحل الطويل الأجل لتخزين صور الحاويات هو [زينودو. rg](https://zenodo.org/) الذي يسمح بما يصل إلى 50 جيغابايت لكل مستودع. بما أن تعدين zenodo DOIs لجميع المحتويات التي تم تحميلها، فإن الصور يمكن الاستشهاد بها على الفور. In contrast to [Docker Hub](https://hub.docker.com/) (which also only accepts docker images), zenodo is also clearly geared towards long-term storage and discoverability via a sophisticated metadata system. ومن ثم فهو مناسب بشكل مثالي لتخزين الحاويات العلمية المرتبطة بتحليلات معينة لأن هذه الحاويات لا تتغير بمرور الوقت.

(rr-renv-buers-warning)=
## كلمات التحذير

وعلى الرغم من أن التفرد والمركبة قد تبدو متماثلة، فإنهما مختلفان جدا من الناحية المفاهيمية. وإلى جانب الحقيقة الواضحة المتمثلة في أن التفرد لا يتطلب الوصول الجذري إلى الحاويات المشغّلة، كما أنه يعالج التمييز بين نظام ملفات الحاويات والمضيف بطريقة مختلفة. على سبيل المثال، بشكل افتراضي، تتضمن الوحدة بضع نقاط ربط في الحاوية، وهي:

- `$HOME`
- `/sys:/sys`
- `/proc:/proc`
- `/tmp:/tmp`
- `/var/tmp:/var/tmp`
- `/etc/resolv.conf:/etc/resolv.conf`
- `/etc/passwd:/etc/passwd`
- `$PWD`

ملاحظة: `$PWD` يأتي في متناول اليد، لأنه يعني أن جميع الملفات في دليل العمل مرئية داخل الحاوية. غير أن ربط `$HOME` بشكل افتراضي يعني أيضا أن البرنامج باستخدام ملفات التكوين من `$HOME` قد يتصرف بشكل غير متوقع لأن ملفات التكوين الخاصة بالصورة قد تم الكتابة فوقها مع إعدادات المستخدمين الحاليين في `$HOME`. وفي حين أن هذا السلوك مفيد في سيناريوهات مركبات الكربون الهيدروكلورية فلورية، فإنه يحتمل أن يكون خطراً على البحوث القابلة للتكرار. وتفاديا للمشاكل المحتملة، ينبغي الإشارة إلى أي برنامج حاسوبي مركب في حاوية مفردة إلى ملف تشكيل عالمي مستقل للمستعملين.
