(اختبار - تحديات)=
# التحديات والحالات الاستثنائية في الاختبار

(r-testting-challenges es-stochastic-code)=
## اختبار الرمز البلاستيكي

في بعض الأحيان تحتوي التعليمات البرمجية على عنصر عشوائي، مثال شائع على التعليمات البرمجية التي تستخدم [طرق مونت كارلو](https://en.wikipedia.org/wiki/Monte_Carlo_method). اختبار هذا النوع من التعليمات البرمجية قد يكون صعباً جداً لأنه إذا تم تشغيله عدة مرات فإنه سيولد إجابات مختلفة، كل ما قد يكون "صحيحاً"، حتى أنه لا يحتوي على أي أخطاء. وهناك طريقتان رئيسيتان لمعالجة اختبار شفرة البلاستيك:

### استخدام بذور أرقام عشوائية

أعداد عشوائية من البذور يصعب تفسيرها قليلاً لذلك هنا مثال. إليك نص بايثون صغير يطبع ثلاثة أرقام عشوائية.

```python
استيراد عشوائي

# طباعة ثلاثة أرقام عشوائية
print(random.random())
print(random.random())
print(random.random())
```

هذا البرنامج النصي لا يحتوي على أي أخطاء ولكن إذا قمت بتشغيله بشكل متكرر، فستحصل على إجابات مختلفة في كل مرة. الآن دعونا نعيّن رقم عشوائي.

```python
استيراد عشوائي

# تعيين رقم عشوائي
عشوائي.seed(1)

# طباعة ثلاثة أرقام عشوائية
طبعة (random.random())
print(random.random())
print(random.random())
```

الآن إذا قمت بتشغيل هذا البرنامج النصي فإنه يخرجه

```python

0.134364244112 
 0.847433736937
0.763774618977
```

وفي كل مرة تقوم بتشغيل هذا البرنامج النصي ستحصل على *نفس* الإخراج، سيطبع *نفس* ثلاثة أرقام عشوائية. إذا تم تغيير رقم البذور العشوائي ستحصل على ثلاثة أرقام عشوائية مختلفة:

```python
0.956034271889
0.947827487059
0.0565513677268
```
ولكن مرة أخرى ستحصل على نفس الأرقام في كل مرة يتم تشغيل البرنامج النصي في المستقبل.

البذور العشوائية هي طريقة لجعل الأشياء عشوائية بشكل موثوق. غير أن خطر الاختبارات التي تعتمد على أعداد عشوائية هو أنها يمكن أن تكون حبيسة. قل أن لديك دالة منظمة مثل هذا:

```python
def my_function():
  a = calculation_that_uses_two_random_numbers()
  b = calculation_that_uses_five_random_numbers()
  c = a + b
```

إذا قمت بتعيين رقم عشوائي للبذور سوف تحصل دائما على نفس القيمة من `c`، بحيث يمكن اختبارها. لكن، قل أن النموذج قد تغير والدالة التي تحسب `A` تستخدم عددا مختلفا من الأرقام العشوائية التي قامت بها من قبل. الآن لن يكون `` مختلفا فقط ولكن `ب` سيكون أيضا لأنه كما هو موضح أعلاه الأعداد العشوائية التي يتم إخراجها بسبب رقم عشوائي هي بترتيب ثابت. ونتيجة لذلك، فإن الأرقام العشوائية المنتجة لحساب `b` ستكون قد تغيرت. وهذا يمكن أن يؤدي إلى فشل الاختبارات عندما لا يكون هناك في الواقع أي خطأ.

#### قياس توزيع النتائج

طريقة أخرى لاختبار التعليمات البرمجية مع مخرجات عشوائية هي تشغيلها مرات عديدة واختبار توزيع النتائج. ولعل النتيجة قد تتقلب قليلا، ولكن من المتوقع دائما أن تكون حوالي 10 في إطار قدر من التسامح. ويمكن اختبار ذلك. كلما زاد عدد المرات التي يتم فيها تشغيل التعليمات البرمجية كلما كان المتوسط أكثر موثوقية، وبالتالي كانت النتيجة. لكن، كلما قمت بتشغيل قطعة من التعليمات البرمجية كلما استغرق الأمر اختبارك فترة أطول، وهو ما قد يجعل إجراء الاختبارات يستغرق وقتاً طويلاً بدرجة تحول دون الحصول على نتيجة موثوقة. وعلاوة على ذلك، سيكون هناك دائما عنصر عدم يقين وإذا سقطت الأعداد العشوائية بطريقة معينة قد تحصل على نتيجة خارج نطاق التسامح المتوقع حتى لو كانت التعليمات البرمجية صحيحة.

وكلا هذين النهجين في اختبار الشفرة البلاستيكية يمكن أن يكونا مفيدين جدا، ولكن من المهم أيضا أن نكون على وعي بمخاطبهما المحتملة.

(r-test-challenges -difficult-quatify)=
## الاختبارات التي يصعب قياسها كمياً

في بعض الأحيان (ولا سيما في مجال البحث) يتم اختبار نواتج التعليمات البرمجية وفقاً لما إذا كانت "تنظر" صحيحة. على سبيل المثال ، لدينا رمز نمذجة لمستويات المياه في خزان مع مرور الوقت.

قد تبدو النتيجة هكذا:

```{figure} ../../figures/eyeball-test1.jpg
---
Name: eyeball test1
alt:
---
```

في يوم واحد مع المطر قد يبدو هكذا:

```{figure} ../../figures/eyeball-test2.jpg
---
Name: eyeball test2
alt:
---
```

وفي يوم جاف قد تبدو هكذا:

```{figure} ../../figures/eyeball-test3.jpg
---
الاسم: اختبار eyeball 3
البديل
---
```

وتبدو جميع هذه النواتج مختلفة جدا ولكنها صالحة. غير أنه إذا رأى أحد الباحثين نتيجة كهذه:

```{figure} ../../figures/eyeball-test-error.jpg
---
Name: eyeball test-error
alt:
---
```

ويمكنها بسهولة أن تخلص إلى وجود خلل لأن من غير المرجح أن تزيد البحيرة حجمها ثلاث مرات ثم تفقدها مرة أخرى في غضون ساعات قليلة. اختبارات "العين" مثل هذه تستغرق وقتاً طويلاً كما يجب أن يقوم بها الإنسان. غير أن هذه العملية يمكن أن تكون آلية جزئيا أو كليا عن طريق إنشاء "فحوص عافية" أساسية. فعلى سبيل المثال، ينبغي أن يكون مستوى المياه في وقت ما في حدود 10 في المائة من مستوى المياه في الخطوة السابقة على سبيل المثال. ويمكن أن يكون التحقق الآخر أنه لا توجد قيم سلبية، حيث لا يمكن للبحيرة أن تكون ممتلئة بنسبة 30٪. هذا النوع من الاختبارات لا يمكن أن يغطي كل طريقة يمكن أن يكون فيها شيء خاطئا ظاهرا، ولكنها أسهل بكثير في التشغيل الآلي وستكفي في معظم الحالات.

(r-testting-challenges es-non-integer)=
## اختبار إذا كانت الأرقام غير الصحيحة متساوية

### عندما لا يساوي 0.1 + 0.2 0.3

هناك تعقيدات مع الاختبار إذا كانت الإجابة على جزء من مخرجات التعليمات البرمجية مساوية للإجابة المتوقعة عندما تكون الأرقام غير صحيحة. دعونا ننظر إلى مثال بايثون هذا، لكن نلاحظ أن هذه المشكلة لا تنفرد بها بايتون.

إذا قمنا بتعيين 0.1 إلى `A` و 0.2 إلى `b` وطباعة المبلغ الخاص بهم، نحصل على 0.3، كما هو متوقع.

```python
>>> a = 0.1
>>> b = 0.2
>>> print(+ b)
0.3
```

ولكن إذا قمنا بمقارنة نتيجة `` + `b` إلى 0.3 فإننا نحصل على خطأ ما.

```python
>>> print(+ b == 0.3)
False
```

إذا نظرنا إلى قيمة `` + `b` مباشرة، يمكننا أن نرى أن هناك هامش خطأ دقيق.

```python
>>> a + b
0.3000000000004
```

ويرجع ذلك إلى أن أرقام النقاط العائمة هي أرقام تقريبية للأرقام الحقيقية. ويمكن أن تعتمد نتيجة الحسابات بالنقاط العائمة على المترجم أو المترجم الشفوي أو المعالج أو بنية النظام وعدد وحدات المعالجة المركزية أو العمليات المستخدمة. ويمكن أن يشكل ذلك عقبة رئيسية أمام اختبارات الكتابة.

### المساواة في عالم ذي نقطة عائمة

وعند مقارنة أرقام النقاط العائمة للمساواة، علينا أن نقارنها في إطار تسامح معين، ويطلق عليها بدلا من ذلك عتبة أو دلتا على سبيل المثال وقد نعتبر أن القيم المحسوبة والمتوقعة لبعض الأعداد متساوية إذا كانت القيمة المطلقة لاختلافها في حدود القيمة المطلقة لتسامحنا.

ويوفر العديد من أطر الاختبار وظائف لمقارنة المساواة بين الأعداد ذات النقاط العائمة في إطار تسامح معين. وعلى سبيل المثال بالنسبة لاختبار الإطار:

```python
import pytest

a = 0.1
b = 0.2
c = a + b
assert c == pytest.approx(0.3)
```

هذا المرور ، ولكن إذا تم تغيير 0.3 إلى 0.4 ، فإن ذلك سيفشل.

وكثيرا ما توفر أطر اختبار الوحدات للغات الأخرى أيضا وظائف مماثلة:

- وحدة C: CU_ASSERT_DOUBLE_EQUAL(فعلي، متوقع، حبيبي)
- CPPUnit ل<unk> C++: CPPUNIT_ASSERT_DOUBLES_EQUAL(متوهعي فعليي دلتا)
- اختبار جوجل لـ C++: ASSERT_NEAR(val1, val2, abs_error)
- FRUIT ل<unk> Fortran: zt_eq_double_in_range_(var1, var2, delta, message)
- الوحدة المشتركة من أجل جافا: org.junit.Assert.assertEquals(كان متوقعا، فعلي مزدوج، دلتا مزدوجة)
- اختبار ل R:
  - expect_equal(فعلي, متوقع, التسامح =DELTA) - خطأ مطلق داخل DELTA
  - expect_equal(فعلي, متوقع, scale=توقع, tolerance=DELTA) - خطأ نسبي داخل DE L T A
