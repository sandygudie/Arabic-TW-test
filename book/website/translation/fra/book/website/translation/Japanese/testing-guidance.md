<a name="General_guidance_and_good_practice_for_testing"></a>

# 一般的なガイダンスとテストの良い練習

{ref}`の異なる種類がいくつかあります`<rr-testing-types-of-testing> それぞれに特有のベストプラクティスがあります それにもかかわらず、それらのすべてに適用されるいくつかの一般的なガイダンスがあります。

(rr-testing-write-tests)=
## テストを書く - 任意のテスト!

特に大きなコードベースを持っている場合は、テストを書くプロセスを開始するのは圧倒的なことがあります。 さらに、前述のように、テストの多くの種類があり、それらのすべてを実装することは、登ることが不可能な山のように見えることができます。 ですから、この章で最も重要なガイダンスは以下の通りです: **いくつかのテストを書く**. 何千行ものコードの中で小さなものをテストすることは、何千行ものコードの中でテストすることよりも、無限に優れています。 You may not be able to do everything, but doing *something* is valuable.

可能な限り改善する 新しいコードでテストを含めるように頑張ってください既に書かれているすべてのコードに対してテストを書くことは不可能です。

## テストの実行

この章の2番目に重要なアドバイス:テストを実行します。 美しい、完璧なテストスイートを持っていることは、めったに実行しない場合は役に立ちません。 テストラン間に長いギャップを残すと、テストが失敗したときに何が間違っていたかを追跡することがより困難になります。 多くのコードが変更されるでしょう また、テストが実行され、それらが失敗してから数週間または数ヶ月が経っている場合。 平均してどの結果が有効か分からないのは難しいか不可能です 虫の影響を受けるように捨てなければならないのです

可能な限りテストを自動化することをお勧めします。 各テストを個別に実行する必要がある場合は、その退屈な苦痛プロセスは無視される可能性があります。 これは、テストフレームワークを利用することによって行うことができます ([後述の](#use-a-testing-framework))。 [Jenkins](https://jenkins.io) はこのためのもう一つの良いツールです。 理想的には、定期的にテストを実行するように設定します。

継続的インテグレーション(継続的インテグレーション章で説明)をプロジェクトに設定することを検討してください。 コードを変更するたびにテストが自動的に実行されます。 継続的な統合ソフトウェアに応じてテストに失敗した場合に通知します

## テストを実行するのにどのくらい時間がかかるかを考えてみましょう

{ref}`rr-testing-unittest` のようないくつかのテストは、小さなコードのみをテストするため、通常は非常に高速です。 しかし、コード全体を最後から最後までテストする {ref}`rr-testing-systemtest` のような他の種類のテスト コードに応じて実行に時間がかかることがあります このように、作業の各ビットの後にテストスイート全体を実行することは妨げになる可能性があります。 その場合、頻繁にユニットテストなどの軽量化試験を実施し、長いテストは一日一回のみ行う方が良いと思います。 また、実行にかかる時間に関連して、各種のテストの数を調整することもできます。 多くの単体テスト(または高速な他のタイプのテスト)を持つべきですが、実行に時間がかかるテストははるかに少ないはずです。

## テストと実行方法を記録する

テストの実行方法を説明するドキュメントを提供することが重要です。 未来のプロジェクトに戻ってきてくれるなら あなたの作品を再現したいと願う人のために。 このドキュメントは次のような主題を扱う必要があります

- 必要なテストデータセットファイルなどの任意のリソース
- テストを実行するために必要な設定/設定の調整
- どのソフトウェア( [フレームワークのテスト](#use-a-testing-framework)など)をインストールする必要があります。

理想的には、必要なリソースを設定して構成するスクリプトを提供します。

## 現実的なケースをテスト

あなたがテストケースをできるだけ現実的にします。 例えば 実際のデータとできるだけ同じようにテストを実行するダミーデータを持っている 実際のデータが多くの null 値で厄介な場合、テストデータセットもそうであるべきです。

## テストフレームワークの使用

テストの書き込みと実行を容易にするためのツールがあります。これらはテストフレームワークとして知られています。 あなたが好きなものを見つけて、それが提供する機能について学び、それらを利用してください。 一般的なテストフレームワーク(およびそれらが適用する言語)は次のとおりです。

- 非依存言語
  - CT、実行可能ファイルのテストランナー、bashスクリプトなど。 レガシーコードの硬化に最適です
- C++
  - キャッチする
  - Test Cppp
  - テスト
  - test google
- C
  - すべての C++ フレームワーク
  - チェック
  - CUnit
```{note}
最新のC++とCは今でも互換性がありますが、完全ではなく、テストフレームワークを相互に使用することで常に機能するとは限りません。
```
- Python
  - pytest (<unk> <unk> )
  - unittest には標準の Python ライブラリが付属しています
- R 単位テスト
  - テスト
  - tinytest
  - svUnit (SciViews GUI い<unk> <unk> <unk> しま<unk> )
- Fortran 単位テスト:
  - funit
  - pfunit (MPIで動作)

## 良いコードカバレッジを持つことを目指してください

コードカバレッジとは、テストでどの程度コードが「カバーされるか」を示す指標です。 より正確には、テストが実施されたときにコードがどのくらい実行されるかを測定します。 例えば If you have an `if` statement but only test things where that if statementが「False」と評価する場合、ifブロック内のコードのどれも実行されません。 結果として、あなたのコードカバレッジは < 100%になります。 コードカバレッジにはコメントのようなドキュメントは含まれていないため、より多くのドキュメントを追加するとパーセンテージに影響はありません。

検討したように、テストはテストなしで改善されます。 それにもかかわらず、少なくとも可能な限り高いコードカバレッジを目指すことは良いことです。

ほとんどのプログラミング言語には、ツールが組み込まれているか、インポートできるか、またはテストフレームワークの一部として、コードカバレッジを自動的に測定できます。 コードカバレッジを測定するための [小さなボット](https://codecov.io/) もあります。

**Pitfall: 適切なカバレッジの錯覚。** 場合によっては、同じコードが複数の方法でテストされることがあり、おそらく必要があります。 例えば、カバレッジは、"健全性チェック"テストをその出力に適用するコードをすばやく増やすことができます。( {ref} も参照)<rr-testing-challenges-difficult-quatify>しかし、これはコードが間違った理由から広範囲に正しい答えを生み出しているリスクを妨げるものではありません。 一般的に、コヒーレントコードの大きな塊ではなく、小さいブロックを分離する最良のテストがあります。 個々の論理のステップを選びます 全体の実行中に特定のコードの塊に起こる可能性があることを考えることによって導かれるようにしてください。 個々の症例をテストすることができます 多くの場合、同じコードが複数回テストされることになります。これは良いことです。

## 適切な場合にテストダブル/スタブ/モックを使用

テストが失敗した場合は、できるだけ簡単に失敗の原因を追跡できるように構築する必要があります。 これは、不可避的にテストしたいコードの一部が他のものに依存する場合に問題になります。 例えば、Webと相互作用するコードの一部のテストが失敗した場合。 インターネット接続に問題があるため、コードにバグ *や* がある可能性があります。 同様に、オブジェクトを使用するコードの一部のテストが失敗した場合、テストされているコードにバグがあるためです。 またはオブジェクトに関する問題(それ自身の別々のテストによってテストされるべきです)。 可能な場合、これらの依存関係はテストから除去される必要があります。 これは、実際の依存関係の代わりにテスト交換(テストダブル)を使用することによって行うことができます。 テストダブルスは以下のように分類できます:

- ダミーオブジェクトは渡されますが、使用されることはありません。つまり、メソッドは呼び出されません。 このようなオブジェクトは、例えばメソッドのパラメータリストを埋めるために使用できます。
- 偽のオブジェクトは動作する実装を持っていますが、通常は簡略化されます。 たとえば、実際のデータベースではなく、メモリ内データベースを使用します。
- スタブは、テスト中にこのスタブのインスタンスを使用する目的を持つインターフェイスまたはクラスの部分的な実装です。 Stubsは通常、テスト用にプログラムされたもの以外のものには応答しません。 Stubsは通話に関する情報を記録することもできます。
- モックオブジェクトは、インターフェイスや特定のメソッド呼び出しの出力を定義するクラスのダミー実装です。 モックオブジェクトは、テスト中に特定の動作を実行するように構成されています。 通常、システムとの相互作用を記録し、テストはそれを検証することができます。

テストダブルスは、テストされる他のオブジェクトに渡すことができます。

モックオブジェクトを手動で作成することも、モックフレームワークを使用してこれらのクラスをシミュレートすることもできます。 モックフレームワークを使用すると、実行時にモックオブジェクトを作成し、その動作を定義することができます。 モックオブジェクトの古典的な例はデータプロバイダです。 本番環境では、実際のデータソースに接続する実装が使用されます。 しかし、モックオブジェクトをテストする場合は、データソースをシミュレートし、テスト条件が常に同じであることを保証します。
